#include <GL\glew.h>
#include <GLFW\glfw3.h>
#include <string>
#include <iostream>
#include <fstream>
#include <cmath>
#include <glm\glm.hpp>
#include <glm\gtc\type_ptr.hpp>
#include <glm\gtc\matrix_transform.hpp>
#include "Utils.h"
using namespace std;
#define numVAOs 1
#define numVBOs 2
float cameraX, cameraY, cameraZ;
float cubeLocX, cubeLocY, cubeLocZ;
GLuint renderingProgram;
GLuint vao[numVAOs];
GLuint vbo[numVBOs];
// allocate variables used in display() function, so that they won’t need to be allocated during rendering
GLuint mvLoc, projLoc;
int width, height;
float aspect;
glm::mat4 pMat, vMat, mMat, mvMat;


void setupVertices (void)
	{
	/*
	A square has 6 sides, 2 triangles makes up a square, so twelve triangles.  Each triangle has 3 verticies, which makes 36 verticies.  Finally, each point is described by three values (x, y, z), for a total of 108 values.
	*/
	float vertexPositions[108] = {
	-1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f,
	1.0f, -1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, -1.0f,
	1.0f, -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, -1.0f,
	1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, -1.0f,
	1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f,
	-1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f,
	-1.0f, -1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f, 1.0f,
	-1.0f, -1.0f, -1.0f, -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f,
	-1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, -1.0f,
	1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, -1.0f, 1.0f,
	-1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, 1.0f,
	1.0f, 1.0f, 1.0f, -1.0f, 1.0f, 1.0f, -1.0f, 1.0f, -1.0f
		};
	// Set up VAO and two VBOs
	glGenVertexArrays (1, vao); // VAO is Vertex Array Object and it stores info for complete rendered objects
	glBindVertexArray (vao[0]);
	glGenBuffers (numVBOs, vbo); // VBO is Vertex Buffer Obejct and provides methods for uploading vertex data
	glBindBuffer (GL_ARRAY_BUFFER, vbo[0]);
	glBufferData (GL_ARRAY_BUFFER, sizeof (vertexPositions), vertexPositions, GL_STATIC_DRAW);
	}


void init (GLFWwindow* window)
	{
	renderingProgram = Utils::createShaderProgram ("res/shaders/basicSquare/basic.vert", "res/shaders/basicSquare/basic.frag");
	cameraX = 0.0f; cameraY = 0.0f; cameraZ = 8.0f;
	cubeLocX = 0.0f; cubeLocY = -2.0f; cubeLocZ = 0.0f; // shift down Y to reveal perspective
	setupVertices ();
	}


void display (GLFWwindow* window, double currentTime)
	{
	glClear (GL_DEPTH_BUFFER_BIT);
	glUseProgram (renderingProgram); // Enables the use of shaders
	// get the uniform variables for the MV and projection matrices
	mvLoc = glGetUniformLocation (renderingProgram, "mv_matrix");
	projLoc = glGetUniformLocation (renderingProgram, "proj_matrix");
	// build perspective matrix
	glfwGetFramebufferSize (window, &width, &height);
	aspect = (float)width / (float)height;
	pMat = glm::perspective (1.0472f, aspect, 0.1f, 1000.0f); // 1.0472 radians = 60 degrees
	// build view matrix, model matrix, and model-view matrix
	vMat = glm::translate (glm::mat4 (1.0f), glm::vec3 (-cameraX, -cameraY, -cameraZ));
	mMat = glm::translate (glm::mat4 (1.0f), glm::vec3 (cubeLocX, cubeLocY, cubeLocZ));
	mvMat = vMat * mMat;
	// copy perspective and MV matrices to corresponding uniform variables
	glUniformMatrix4fv (mvLoc, 1, GL_FALSE, glm::value_ptr (mvMat));
	glUniformMatrix4fv (projLoc, 1, GL_FALSE, glm::value_ptr (pMat));
	// associate VBO with the corresponding vertex attribute in the vertex shader
	glBindBuffer (GL_ARRAY_BUFFER, vbo[0]);
	glVertexAttribPointer (0, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glEnableVertexAttribArray (0);
	// adjust OpenGL settings and draw model
	glEnable (GL_DEPTH_TEST);
	glDepthFunc (GL_LEQUAL);
	glDrawArrays (GL_TRIANGLES, 0, 36);
	}


int main (void)
	{ // main() is unchanged from before
	if (!glfwInit ()) { exit (EXIT_FAILURE); }
	glfwWindowHint (GLFW_CONTEXT_VERSION_MAJOR, 4);
	glfwWindowHint (GLFW_CONTEXT_VERSION_MINOR, 3);
	GLFWwindow* window = glfwCreateWindow (600, 600, "basicSquare", NULL, NULL);
	glfwMakeContextCurrent (window);
	if (glewInit () != GLEW_OK) { exit (EXIT_FAILURE); }
	glfwSwapInterval (1);
	init (window);
	while (!glfwWindowShouldClose (window))
		{
		display (window, glfwGetTime ());
		glfwSwapBuffers (window);
		glfwPollEvents ();
		}
	glfwDestroyWindow (window);
	glfwTerminate ();
	exit (EXIT_SUCCESS);
	}